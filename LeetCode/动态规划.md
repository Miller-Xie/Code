* **动态规划总结**

   * [爬楼梯](#爬楼梯) (`easy`)
   * [买卖股票的最佳时机](#买卖股票的最佳时机) (`easy`)
   * [买卖股票的最佳时机III](#买卖股票的最佳时机III) (`hard` `分治`)
   * [最大子序和](#最大子序和) (`easy`)
   * [打家劫舍](#打家劫舍) (`easy`)
   * [最小路径和](#最小路径和) (`medium`)
   * [不同路径](#不同路径) (`medium`)
   * [三角形最小路径和](#三角形最小路径和) (`medium`)
   * [最大上升子序列](#最大上升子序列) (`medium` `贪心`)
   * [俄罗斯套娃信封问题](#俄罗斯套娃信封问题) (`hard` `贪心`)
   * [递增的三元子序列](#递增的三元子序列) (`medium` `贪心`)
   * [最大正方形](#最大正方形) (`medium`)
   * [摆动序列](#摆动序列) (`medium` `贪心`)
   * [零钱兑换](#零钱兑换) (`medium` `背包问题`)
   * [最大回文子串](#最大回文子串) (`medium`)
   * [无重复字符的最长子串](#无重复字符的最长子串) (`medium` `hash` `滑动窗口`)
   * [戳气球](#戳气球) (`hard`)
   * [最长等差数列](#最长等差数列) (`medium`)
   * [最长递增子序列的个数](#最长递增子序列的个数) (`medium`)
   * [接雨水](#接雨水) (`hard`)

     
# 动态规划总结
## 爬楼梯
[LeetCode中文](https://leetcode-cn.com/problems/climbing-stairs)

[LeetCode英文](https://leetcode.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意**：给定 n 是一个正整数。

**示例 1**：
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2**：
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

### 解答

* python代码

```python
class Solution:
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 0:
            return 0
        elif n == 1:
            return 1
        elif n == 2:
            return 2
        
        dp = list()
        dp.append(1)
        dp.append(2)
        
        for i in range(2,n):
            dp.append(dp[i-1] + dp[i-2])
            
        return dp[-1]
```



## 买卖股票的最佳时机 

[LeetCode中文](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)

[LeetCode英文](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**示例 1**:

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```
**示例 2**:

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

### 解答

[方法详解](https://leetcode-cn.com/articles/best-time-to-buy-and-sell-stock/)

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int len = prices.size();
        vector<int> dp(len,0);
        int max = 0;
        int min = prices[0];
        for(int i=1;i<len;i++)
        {
            dp[i] = prices[i]-min;
            if(prices[i] < min)
            {
                 min = prices[i];
            }
	    
            if(max < dp[i]) max = dp[i];
        }
	
        return max;
    }
};
```

* 空间优化

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        int len = prices.size();
        int maxp = 0;
        int minp = prices[0];
        for(int i=1;i<len;i++)
        {
            int tmp = prices[i] - minp;
            maxp = max(tmp,maxp);
            minp = min(prices[i],minp);
        }
	
        return maxp;
    }
};
```

**Python代码**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) == 0:
            return 0
        minp = prices[0]
        maxp = 0
        for i in range(1,len(prices)):
            tmp = prices[i] - minp
            maxp = max(tmp,maxp)
            minp = min(prices[i],minp)
        return maxp
```



## 最大子序和

[LeetCode中文](https://leetcode-cn.com/problems/maximum-subarray)

[LeetCode英文](https://leetcode.com/problems/maximum-subarray)

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例**:
```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶**:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

### 解答

#### 方法1

动态规划，开辟一个数组`dp`，`dp[i]`表示已数字`nums[i]`结尾的连续子数组的最大子序和，动态转移方程为：
  1. 如果`dp[i-1] < 0`,则`dp[i] = nums[i]`；
  2. 若`dp[i-1] > 0`,则`dp[i] = dp[i-1] + nums[i]`；
其中`nums[i]`表示遍历到的元素（*0 <= i <= nums.size()-1*），求出`dp`数组元素的**最大值**就是整个数组的最大子序和。

* 空间复杂度：O(*n*)
* 时间复杂度：O(*n*)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int len = nums.size();
        if(len == 0)
            return 0;
        
        vector<int> dp(len,0);
        dp[0] = nums[0];
        int max = nums[0];
        for(int i=1;i<len;i++)
        {
            if(dp[i-1] < 0)
                dp[i] = nums[i];
            else
                dp[i] = dp[i-1] + nums[i];
            
            if(dp[i] > max)
                max = dp[i];
        }
        
        return max;
    } 
};
```

#### 方法2

优化空间，定义`sum`表示**可能的最大子序和**，`Max`变量表示**最大子序和**。遍历数组，每遍历到一个元素`nums[i]`,先判断`sum`的值的正负，分两种情况：
   1. 如果`sum < 0`，重新赋值`sum = nums[i]`；
   2. 如果`sum >= 0`，累加`sum += nums[i]`；

每遍历一个元素`nums[i]`,都`Max`为`sum`和`Max`两者较大值，即`Max` = `max(Max,sum)`，最终`Max`就是整个数组的最大子序和。此方法不需要开辟数组`dp`，只需要用两个变量`sum`和`Max`。

这里举例说明：例如`-2,1,2,-3`组成的数组，当遍历到1的时候，`sum` = `-1`为负，那么在当前元素2加上之前元素累加得到的负数`sum`不可能是**最大子序和**，在这种情况下，令`sum` = `当前元素`，忽略前面已经累加得到的负值；否则，直接在`sum`上累加当前元素`nums[i]`。最后遍历完整个数组，得到的`Max`即为所求。

* 空间复杂度：O(1)
* 时间复杂度：O(*n*)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        int len = nums.size();
        int sum = 0;
        int Max = INT_MIN;
        for(int i=0;i<len;i++)
        {
            if(sum < 0)
            {
                sum = nums[i];
            }
            else
                sum += nums[i];
            
            Max = max(sum,Max);
        }
        
        return Max;
    }
};
```



## 打家劫舍
[LeetCode中文](https://leetcode-cn.com/problems/house-robber)

[LeetCode英文](https://leetcode.com/problems/house-robber)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**示例 1**:

```
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2**:

```
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

### 解答

[参考博客](https://www.cnblogs.com/grandyang/p/4383632.html)

* c++代码

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        int len = nums.size();
        if(len == 1) return nums[0];
        
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[1],nums[0]);
        for(int i=2;i<len;i++)
        {
            dp[i] = max(dp[i-1] , nums[i] + dp[i-2]);
        }
        
        return dp.back();
    }
};
```

* python代码

```python
class Solution:
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        
        sum_odd = 0
        sum_even = 0
        for i,num in enumerate(nums):
            if i%2 == 0:
                sum_even = max(num + sum_even , sum_odd)
            else:
                sum_odd = max(num + sum_odd , sum_even)
        
        return max(sum_odd,sum_even)
```



## 最小路径和

[LeetCode中文](https://leetcode-cn.com/problems/minimum-path-sum)

[LeetCode英文](https://leetcode.com/problems/minimum-path-sum)

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

**示例**:

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

### 解答

动态规划的最小路径问题，开辟二维数组`dp`，设`dp[i][j]`表示到位置`grid[i][j]`的最小路径和。

动态转移方程：

```
dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1])
```

设二维矩阵的行数为`h`，列数为`l`，则`dp[h - 1][l - 1]`即为所求。

* 时间复杂度O(*mn*)
* 空间复杂度O(*mn*)

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int h = grid.size();
        int l = grid[0].size();
        vector<vector<int>> dp(h,vector<int>(l,0));
        
        dp[0][0] = grid[0][0];
        for(int i=1;i<h;i++)
        {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        
        for(int i=0;i<l;i++)
        {
            dp[0][i] = dp[0][i-1] + grid[0][i];
        }
        
        for(int i=1;i<h;i++)
        {
            for(int j=1;j<l;j++)
            {
                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
            }
        }
        
        return dp[h-1][l-1];
    }
};
```



## 不同路径

[LeetCode中文](https://leetcode-cn.com/problems/unique-paths)

[LeetCode英文](https://leetcode.com/problems/unique-paths)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

说明：m 和 n 的值均不超过 100。

**示例 1**:
```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

**示例 2**:

```
输入: m = 7, n = 3
输出: 28
```

### 解答

思路同 [最小路径和](#最小路径和)，设`dp[i][j]`表示到网格中`i`行`j`列位置的路径数：

动态转移方程为：

```
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

设网格的行数为*n*，列数为*m*，则`dp[m-1][n-1]`即为所求。

* 时间复杂度：O(*mn*)
* 空间复杂度：O(*mn*)

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m == 0 || n == 0)
            return 0;
        
        vector<vector<int>> dp(n,vector<int>(m,0));
        for(int i=0;i<m;i++)
            dp[0][i] = 1;
        for(int j=1;j<n;j++)
            dp[j][0] = 1;
        
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
            {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        
        return dp[n-1][m-1];
    }
};
```



## 三角形最小路径和

[LeetCode中文](https://leetcode-cn.com/problems/triangle)

[LeetCode英文](https://leetcode.com/problems/triangle)

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：
```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

**说明**：

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

### 解答
#### 方法1

开辟二维数组`dp`，由于是三角形结构，`dp`的第`i`个元素`dp[i]`大小为`i+1`(*0 <= i < row*)，设`dp[i][j]`表示从底部到点`triangle[i][j]`走过的最短路径和。

动态转移方程为：

```
dp[i][j] = triangle[i][j] + min(dp[i+1][j],dp[i+1][j+1]) (i = 0~row-1)
```

初始条件为`dp[row - 1][i]` = `triangle[row - 1][i]`(*0 <= i < row*)，从最后一行自下向上递推计算，得出的`dp[0][0]`即为所求。

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(*n<sup>2</sup>*)

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.empty()) return 0;
        
        int row = triangle.size();
        int col = triangle[0].size();
        vector<vector<int>> dp;
        dp.resize(row);
        for(int i=1;i<=row;i++)
        {
            dp[i-1].resize(i,0);
        }
        
        for(int i=0;i<row;i++)
        {
            dp[row-1][i] = triangle[row-1][i];
        }
        
        for(int i=row-2;i>=0;i--)
        {
            for(int j=0;j<=i;j++)
            {
                dp[i][j] = triangle[i][j] + min(dp[i+1][j],dp[i+1][j+1]); 
            }
        }
        
        return dp[0][0];
        
    }
};
```

#### 方法2

空间优化，根据 [方法1](#方法1-1)，在自下向上计算的时候，因为当计算出`dp[i][j]`之后，`dp[i+1][j]`就不用了，所以可以重复利用大小为n的数组，只需要开辟一维数组`dp`，数组大小为`row`。

动态转移方程为： 

```
dp[j] = triangle[i][j] + min(dp[j],dp[j+1]) ( i = 0~row-1 )
```

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(*n*)


```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.empty()) return 0;
        
        int row = triangle.size();
        vector<int> dp(row,0);
        for(int i=0;i<row;i++)
        {
            dp[i] = triangle[row-1][i];
        }
        
        for(int i=row-2;i>=0;i--)
        {
            for(int j=0;j<=i;j++)
            {
                dp[j] = triangle[i][j] + min(dp[j],dp[j+1]);
            }
        }
        
        return dp[0];
        
    }
};
```



## 最大上升子序列

[LeetCode中文](https://leetcode-cn.com/problems/longest-increasing-subsequence)

[LeetCode英文](https://leetcode.com/problems/longest-increasing-subsequence)

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例**:
```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明**:

* 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
* 你算法的时间复杂度应该为 O(n2) 。

**进阶**: 你能将算法的时间复杂度降低到 O(n log n) 吗?

### 解答

#### 方法1

开辟一维数组`dp`，设`dp[i]`表示以`arr[i]`这个数结尾的情况下，以`arr[0]~arr[i]`中的某个数开头的最大递增子序列长度。

动态转移方程：

```
dp[i] = max{dp[j]+1(j=0~(i-1)),且arr[i]>arr[j]}
```

找出数组`dp`中元素的最大值`Max`即为所求。

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(*n*)

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() < 2) return nums.size();
        
        int len = nums.size();
        vector<int> dp(len,1);
        int Max = INT_MIN;
        for(int i=1;i<len;i++)
        {
            for(int j=0;j<i;j++)
            {
                if(nums[j] < nums[i])
                {
                    dp[i] = max(dp[j] + 1,dp[i]);
                }
            }
            
            Max = max(Max,dp[i]);
        }
        
        return Max;
    }
};
```

#### 方法2

贪心法 + 二分查找，优化时间复杂度O(*n log n*)（只能找出最大长度，不能找出正确的最长上升子序列）

新建一个low数组，数组`low`的长度就表示**以`low[i]`(它在数组nums中对应的元素)为结尾元素的LIS的长度**，那么`low[i]`就是**长度为`i+1`的LIS结尾元素的最小值**。对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。因此，我们只需要维护`low`数组，对于每一个`a[i]`，如果`a[i] > low`[当前最长的LIS长度]，就把`a[i]`接到当前最长的LIS后面，即`low[++当前最长的LIS长度]` = `a[i]`。

那么，怎么维护low数组呢？ 对于遍历`nums`的每一个元素`a[i]`，如果`a[i]`能接到LIS后面，就接上去；否则，就用`a[i]`去更新`low`数组更新的方法是，在`low`数组中找到第一个大于等于`a[i]`的元素`low[j]`，用`a[i]`去更新`low[j]`。那么为什么这里要这样更新呢？尽管这样没有改变当前`low`数组的大小，但是会让`low`数组更有"**潜力**"在它后面接上更多的元素，也就越可能变得更长。(这种方法的缺点：得到的low不一定是LIS对应的元素序列，只是和LIS的长度相等)。另外，如果从头到尾扫一遍`low`数组的话，时间复杂度仍是O(*n<sup>2</sup>*)。我们注意到`low`数组内部一定是单调不降的，所以我们可以二分查找`low`数组，找出第一个大于等于`a[i]`的元素，直接利用STL的`lower_bound`函数。二分查找一次`low`数组的时间复杂度的O(*log n*)，所以总的时间复杂度是O(*n log n*)。

* 时间复杂度O(*n log n*)
* 空间复杂度O(*n*)

```c++
class Solution {
public:
     void Replace(vector<int>& vec,int a)
    {
        int l = 0;
        int r = vec.size() - 1;
        while(l < r)
        {
            int m = l + (r - l) / 2;
            if(vec[m] > a)
                r = m;
            else if(vec[m] < a)
                l = m + 1;
            else return;
        }
         
        vec[l] = a;
    }
    
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() == 0) 
            return 0;
        
        vector<int> low;
        low.push_back(nums[0]);
        for(int i=1;i<nums.size();i++)
        {
            //lower_bound 底层是使用二分查找
            auto iter = lower_bound(low.begin(),low.end(),nums[i]);
            if(iter == low.end())
                low.push_back(nums[i]);
            else
                *iter = nums[i];
        }
        
        return low.size();
    }
};
```

#### 方法3：树状数组(`待续。。。`)

```c++

```



## 最大正方形

[LeetCode中文](https://leetcode-cn.com/problems/maximal-square/)

[LeetCode英文](https://leetcode.com/problems/maximal-square/)

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

**示例**:
```
输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```

### 解答
#### 方法1

暴力dp，开辟三维数组`dp`，设`dp[i][j][d]`表示以`matrix[i][j]`为起点，边长为`d`的正方形的面积（只要区域中含有`'0'`，面积就是0）

动态转移方程：
1. 当`dp[i][j][d-1] > 0` 且 区域外围都为`'1'` ，则`dp[i][j][d] = d * d`；
2. 其他情况都为 `dp[i][j][d] = 0`。

设`res`表示最大正方形的面积，在递推计算的过程中，取`res`为`res`和`dp[i][j][k]`两者的较大值。最终，得到的`res`即为所求。

* 时间复杂度O(*n<sup>3</sup>*)
* 空间复杂度O(*n<sup>3</sup>*)

```c++
class Solution {
public:
    bool is_ok(int x,int y,int d,const vector<vector<char>>& matrix)
    {
        for(int i=x;i<x+d;i++)
        {
            if(matrix[i][y+d-1] == '0')
                return false;
        }
        
        for(int i=y;i<y+d;i++)
        {
            if(matrix[x+d-1][i] == '0')
                return false;
        }
        
        return true;
    }
    
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty()) return 0;
        
        const int row = matrix.size();
        const int col = matrix[0].size();
        int res = 0;
        
        const int dmax = min(col,row);
        vector<vector<vector<int>>> dp;
        dp.resize(row);
	    for(int i=0;i<row;i++)
	   {
		  dp[i].resize(col);
	   }

	   for(int i=0;i<row;i++)
	   {
		 for(int j=0;j<col;j++)
		 {
			dp[i][j].resize(dmax+1,0);
		 }
	   }
        
        for(int i=0;i<row;i++)
           for(int j=0;j<col;j++)
            {
                dp[i][j][1] = matrix[i][j] == '1' ? 1 : 0;
                res = max(res,dp[i][j][1]);
            }
        
        for(int i=0;i<row;i++)
            for(int j=0;j<col;j++)
                for(int k=2;k<=min(row-i,col-j);k++)
                {
                    if(dp[i][j][k-1] > 0 && is_ok(i,j,k,matrix))
                        dp[i][j][k] = k * k;
                    else
                        dp[i][j][k] = 0;
                    
                    res = max(dp[i][j][k],res);
                }
        
        return res;
    }
};
```

#### 方法2

优化时间效率，开辟二维数组`dp`，设`dp[i][j]` 表示以点`matrix[i][j]`为右下角时，所含有的充满`'1'`的正方形的最大边长。

动态转移方程：

```
dp[i][j] = min(dp[i-1][j-1] , min(dp[i-1][j] , dp[i][j-1])) 
```

**注意**：这个转移方程不太容易想到，可以举例加深理解。

最后得到`dp`数组中的最大元素`res`就是最大正方形的边长，那么最大面积就是`res * res`。

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(*n<sup>2</sup>*)

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty()) return 0;
        
        const int row = matrix.size();
        const int col = matrix[0].size();
        int res = 0;
        
        vector<vector<int>> dp(row,vector<int>(col,0));
        for(int i=0;i<row;i++)
        {
            if(matrix[i][0] == '1')
            {
                res = 1;
                dp[i][0] = 1;
            }
        }
        
        for(int j=0;j<col;j++)
        {
            if(matrix[0][j] == '1')
            {
                res = 1;
                dp[0][j] = 1;
            }
            
        }
        
        for(int i=1;i<row;i++)
            for(int j=1;j<col;j++)
            {
                if(matrix[i][j] == '1')
                {
                    dp[i][j] = min(dp[i-1][j-1] , min(dp[i-1][j],dp[i][j-1]) ) + 1;
                    res = max(res,dp[i][j]);
                }
            }
        
        return res * res;
    }
};
```



## 摆动序列

[LeetCode中文](https://leetcode-cn.com/problems/wiggle-subsequence/)

[LeetCode英文](https://leetcode.com/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1**:

```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```

**示例 2**:
```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

**示例 3**:
```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```

**进阶**:

你能否用 O(n) 时间复杂度完成此题?

### 解答

#### 方法1：动态规划

开辟两个数组`dp1`和`dp2`，其中`dp[i]`表示**到位置i时包含的以正差值结尾的摆动子序列的最大长度**，`dp2[i]`表示**到位置i时包含的以负差值结尾的摆动子序列的最大长度**，我们从`i=1`开始遍历数组，然后对于每个遍历到的数字，再从开头位置遍历到这个数字，然后比较`nums[i]`和`nums[j]`，分别更新对应的位置。 

动态转移方程： 

```
dp1[i] = max{dp2[j]+1 , 0 =< j <= i-1 且 nums[i] > nums[j]} 
dp2[i] = max{dp1[j]+1 , 0 =< j <= i-1 且 nums[i] > nums[j]}
```

遍历结束之后，整个数组的最长摆动子序列就是`max(dp1.back(),dp2.back())`。

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(*n*)

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        vector<int> dp1(nums.size(), 1);
        vector<int> dp2(nums.size(), 1);
        for(int i = 1; i < nums.size();i++) 
        {
            for (int j = 0; j < i; j++) 
            {
                if (nums[i] > nums[j]) dp1[i] = max(dp1[i], dp2[j] + 1);
                else if (nums[i] < nums[j]) dp2[i] = max(dp2[i], dp1[j] + 1);
            }
        }
        
        return max(dp1.back(), dp2.back());
    }
};
```

#### 方法2：贪心法

基于动态规划的方法，优化空间，改用两个变量`p`和`q`，`p`表示**遍历到当前元素`num[i]`以正差值结尾的摆动子序列的最大长度**，`q`表示**遍历到当前元素`num[i]`以负差值结尾的摆动子序列的最大长度**。分两种情况处理：

  1. 当`num[i] > num[i-1]`时，令`p = q+1`；
  2. 当`num[i] < num[i-1]`时，令`q = p+1`。

遍历结束之后，整个数组的最长摆动子序列就是`max(p,q)`。

* 时间复杂度O(*n*)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int p = 1, q = 1, n = nums.size();
        if(n <= 1) return n;
        
        for (int i = 1; i < n; ++i) {
            if (nums[i] > nums[i - 1]) p = q + 1;
            else if (nums[i] < nums[i - 1]) q = p + 1;
        }
        
        return max(p,q);
    }
};
```



## 零钱兑换

[LeetCode中文](https://leetcode-cn.com/problems/coin-change)

[LeetCode英文](https://leetcode.com/problems/coin-change)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

**示例 1**:
```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

**示例 2**:
```
输入: coins = [2], amount = 3
输出: -1
```

**说明**:

你可以认为每种硬币的数量是无限的。

### 解答

动态规划，开辟一维数组，大小为`amount+1`(因为数组dp是从零开始，金额最大值是`amount`),设`dp[i]`为兑换金额`i`所需的最小硬币数，遍历每一个硬币，如果硬币`coins[j]`的金额数小于等于`i`，取`dp[i] = min{dp[i - coins[j]] + 1,j = 0~coins.size()-1}`,状态转移方程为：

```
dp[i] = min{dp[i - coins[j]] + 1 , coins[j] <= i 且 0 <= j < coins.size()}
```

数组初始化：`dp[0] = 0`，其他元素为`INT_MAX`。最后，完成递推计算后，`dp[amount]`即为所求。

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(*n*)

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
       if(coins.size() == 0 || amount == 0) return 0;
        
        vector<int> dp(amount+1,INT_MAX);
        dp[0]=0;
      
        for(int i=1;i<amount+1;i++)
        {
            for(int j=0;j<coins.size();j++)
            {
                if(coins[j] <= i && dp[i - coins[j]] != INT_MAX)
                {
                    dp[i] = min(dp[i],dp[i - coins[j]] + 1);
                }
            }
        }
        
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```



## 最大回文子串

[LeetCode中文](https://leetcode-cn.com/problems/longest-palindromic-substring)

[LeetCode英文](https://leetcode.com/problems/longest-palindromic-substring)

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

**示例 1**：
```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

**示例 2**：
```
输入: "cbbd"
输出: "bb"
```

### 解答

#### 方法1

转换为公共子串问题。设原来的字符串`s`，反转后的字符串`s1`，利用动态规划找出`s`和`s1`的最长公共子串即为`s`的最长回文子串，设`dp[i][j]`表示以*s[0]~s[i]*组成的字符串和以*s1[0]~s1[j]*组成的字符串并且是**以s[i]和s[j]结尾**的公共子串的长度。

动态转移方程：

  1. 如果 `s[i] = s[j]`, 那么 `dp[i][j] = dp[i-1][j-1] + 1`；
  2. 如果 `s[i] = s[j]`，那么 `dp[i][j] = 0`。

数组初始化代码如下
```
if(s[i]==s1[j])     dp[i][j]=dp[i-1][j-1]
else                  dp[i][j]=0

//数组初始化
for(int i=0;i<len;++)
{
if(s[0]==s1[i])    dp[0][i]=1;
if(s[i]==s1[0])     dp[i][0]=1; 
}
```

这种方法有一个问题：找到的公共子串不一定是回文，例如： 

s="abacdfgdcaba" , s1 = "abacdgfdcaba" 

找到的最长子串“abacd”,显然不是回文，因此需要在程序中弥补这个缺陷。 弥补方法很简单：每次找到一个比之前更长的的公共子串时，都判断一次是否是回文。

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(*n<sup>2</sup>*)

```c++

```

#### 方法2：直接动态规划

开辟二维数组`dp`，类型`bool`，设`dp[i][j]`表示*s[i]~s[j]*组成的字符串是否为回文子串。

动态转移方程：

```
dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1] 
```

初始化：先初始化一个字母和两个字母的字符串,初始化公式：

  1. 一字母：`dp[i][i] = true`；  
  2. 两字母：`dp[i][i+1] = (s[i] == s[i+1])`。 

其他的按照动态转移方程类推，就可以得出最长回文子串。

[**参考详解方法三**](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/)

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(*n<sup>2</sup>*)

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        if(s.empty()) return "";
        
        int len = s.size();
        string res;
        int start = 0;
        int Max = 1;
        vector<vector<bool>> dp(len,vector<bool>(len,false));
        
        //初始化一字母
        for(int i=0;i<len;i++)
        {
            dp[i][i] = true;
        }
        
        //初始化两字母
        for(int i=0;i<len-1;i++)
        {
            if(s[i] == s[i+1])
            {
                dp[i][i+1] = true;
                start = i;
                Max = 2;
            }
        }
        
        for(int d=3;d<=len;d++)
            for(int i=0,j=i+d-1;i<len && j<len;i++,j++)
            {
                if(dp[i+1][j-1] && s[i] == s[j])
                {
                    dp[i][j] = true;
                    if(d > Max)
                    {
                        start = i;
                        Max = d;
                    }
                }
            }
        
        res = s.substr(start,Max);
        return res;
    }
};
```

#### 方法3：中心扩展算法

在数组中选取中心元素向两边扩展，直到扩展到两边的元素不相等或者到达边界，就换其他元素进行中心扩展。由于回文串的长度有奇数和偶数两种情况，因此扩展分为两种情况：

   1. 长度为奇数：以一个元素为中心，向两边扩展
   2. 长度为偶数：以两个元素为中心，向两边扩展

找到长度最长的那个回文子串即为所求。

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(1)

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.size();
        if(len == 0)
            return string();
        
        string res;
        int start = 0;
        int Max = 1;
        for(int i=0;i<len;i++)
        {
            int cnt = 1;
            int l = i - 1;
            int r = i + 1;
            while(l >=0 && r < len && s[l] == s[r])
            {
                l--;
                r++;
                cnt += 2;
            }
            
            if(cnt > Max)
            {
                Max = cnt;
                start = l + 1;
            }
        }
        
        for(int i=0;i<len-1;i++)
        {
            int cnt = 0;
            int l = i;
            int r = i+1;
            while(l >= 0 && r < len && s[l] == s[r])
            {
                l--;
                r++;
                cnt += 2;
            }
            
            if(cnt > Max)
            {
                Max = cnt;
                start = l+1;
            }
        }
        
        res = s.substr(start,Max);
        
        return res;
    }
};
```

#### 方法4：Manacher算法(`待续。。`)

```c++

```



## 无重复字符的最长子串

[LeetCode中文](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

[LeetCode英文](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1**:
```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2**:

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3**:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

### 解答

#### 方法1：动态规划
思路：`dp[i]`表示以`i`为下标的字符结尾的最长不重复子串的长度,分两种情况处理
1. 如果`str[i]`在前面没出现，则`dp[i] = dp[i-1] + 1`；
2. 如果`str[i]`在前面出现，设在前面出现的位置为`j`，计算距离`d = i - j`
   * 如果`d > dp[i-1]`，则`dp[i] = dp[i-1] + 1`;
   * 如果`d < dp[i-1]`，则`dp[i] = d`;


* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(1)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;
        
        vector<int> dp(s.size(),0);
        dp[0] = 1;
        
        int res = 1;
        for(int i=1;i<s.size();++i)
        {
            int idx = i-1;
            while(idx >= 0 && s[idx] != s[i]) --idx;
            
            if(idx < 0) dp[i] = dp[i-1] +1;
            else{
                int d = i - idx;
                if(d > dp[i-1]) dp[i] = dp[i-1] + 1;
                else dp[i] = d;
            }
            
            res = max(dp[i],res);
        }
        
        return res;
    }
};
```

#### 方法2：动态规划+hash表
思路和 **方法1** 一样，动态规划。同时利用结构`unordered_map`作为**哈希表**，统计字符目前为止最后一次出现的**位置**(假设递推公式计算到`dp[i]`，那么哈希表统计的是`s[i]`在*0~i-1*最后出现的位置)。这样在递推计算`dp[i]`的时候，避免了在 *0~i-1* 查找`s[i]`的过程，空间换时间，降低了时间复杂度。

* 时间复杂度O(*n*)
* 空间复杂度O(*n*)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;
        
        unordered_map<char,int> mp;
        vector<int> dp(s.size(),0);
        dp[0] = 1;
        mp[s[0]] = 0;
        
        int res = 1;
        for(int i=1;i<s.size();++i)
        {
            if(mp.count(s[i]) == 0) dp[i] = dp[i-1] +1;
            else{
                int d = i - mp[s[i]];
                if(d > dp[i-1]) dp[i] = dp[i-1] + 1;
                else dp[i] = d;
            }
            
            mp[s[i]] = i;
            
            res = max(dp[i],res);
        }
        
        return res;
    }
};
```

#### 方法3：滑动窗口+set/哈希表

[详见阅读详解方法二和方法三](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/)

1）**解法一**：滑动窗口 + `set` 

* 时间复杂度：O(*2n*) = O(*n*)，最坏情况`i`和`j`都被索引了`n`次
* 空间复杂度：O(*n*)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;
        
        int i = 0,j = 0;
        unordered_set<char> st;
        int res = 1;
        while(i < s.size() && j < s.size())
        {
            if(st.count(s[j]) == 0)
            {
                res = max(res,j-i+1);
                st.insert(s[j++]);
            }
            else
            {
                st.erase(s[i++]);
            }
        }
        
        return res;
    }
};
```

2）**解法2**：滑动窗口 + `unordered_map`(**哈希表**)

* 时间复杂度O(*n*)，只有`j`被索引了`n`次
* 空间复杂度O(*n*)

```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;
        
        int i = 0,j = 0;
        unordered_map<char,int> mp;
        int res = 1;
        for(int j=0;j<s.size();++j)
        {
            if(mp.count(s[j]) > 0)
            {
                i = max(mp[s[j]]+1,i);
            }
            
            mp[s[j]] = j;
            res = max(res,j-i+1);
        }
        
        return res;
    }
};
```



## 戳气球

[LeetCode中文](https://leetcode-cn.com/problems/burst-balloons/)

[LeetCode英文](https://leetcode.com/problems/burst-balloons/)

有 `n` 个气球，编号为 `0` 到 `n-1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。

现在要求你戳破所有的气球。每当你戳破一个气球 `i` 时，你可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。

求所能获得硬币的最大数量。

**说明**:

你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100

**示例**:
```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

### 解答

开辟二维数组`dp`，根据题目假设`nums[-1] = nums[len] = 1`,所以`dp`长度设为`len+1`，并在`nums`数组首尾都添加1。设`dp[i][j]`为**戳破编号i~j的气球能获得的最大硬币数**，设k(*i <= k <= j*)是戳完`i~j`这一段气球的最后一个气球，那么`dp[i][j]`的可能值就是`dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1]`，从`i~j`遍历所有的`k`，取这个结果的最大值就是`dp[i][j]`，动态转移方程为：

```
dp[i][j] = max{dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1]} (i <= k <= j)
```

`dp`数组初始化：以气球段的长度为1为起始状态

```
dp[i][i] = nums[i-1] * nums[i] * nums[i+1]
```

往后逐渐递增长度，根据状态转移方程类推即可。

边界问题：注意`k == start`的时候，相当于`start~end`范围内的最左边气球最后被戳破，它右边的气球都先于它被戳破。

* 时间复杂度O(*n<sup>3</sup>*)
* 空间复杂度O(*n*)

```c++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int len = nums.size();
        nums.push_back(1);
        nums.insert(nums.begin(),1);
        
        vector<vector<int>> dp(len+2,vector<int>(len+2,0));
        for(int i=1;i<=len;i++)
        {
            dp[i][i] = nums[i-1]*nums[i]*nums[i+1];
        }
        
        for(int l=2;l<=len;l++)
        {
            for(int start=1;start<=len-l+1;start++)
            {
                int end = start+l-1;
                for(int k=start;k<=end;k++)
                {
                    int old = dp[start][end];
                    int now = nums[start-1]*nums[k]*nums[end+1] + dp[start][k-1] + dp[k+1][end];
                    dp[start][end] = max(old,now);
                }
            }
        }
        
        return dp[1][len];
    }
};
```



## 买卖股票的最佳时机III

[LeetCode中文](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

[LeetCode英文](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 *两笔* 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1**:

```
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3
```

**示例 2**:

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3**:
```
输入: [7,6,4,3,1] 
输出: 0 
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。
```

### 解答
#### 方法1：动态规划

开辟两个二维数组`global`和`local`，定义`global[i][j]`表示 **到第j天最多交易i次** 获得的最大收益，为全局最优。`local[i][j]`表示 **到第j天最多交易i次并且最后一次交易就在第j天卖出** 能获得的最大收益，为局部最优。那么动态转移方程为：

```
local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i][j-1] + diff) (diff表示第i天和前一天股票价格的差值)
global[i][j] = max(local[i][j] , global[i][j-1])
```

递推式的详细讲解 [参考博客](https://blog.csdn.net/linhuanmars/article/details/23236995)，这种方法可以求出交易k次能获得最大收益`global[k][len-1]`，取`k = 2`就能求出交易两次所获得的最大收益`global[2][len-1]`。  

* 时间复杂度O(*n*)
* 空间复杂度O(*n<sup>2</sup>*)

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int len = prices.size();
        vector<vector<int>> global(3,vector<int>(len,0));
        vector<vector<int>> local(3,vector<int>(len,0));
        for(int i=1;i<=2;i++)
            for(int j=1;j<len;j++){
                int diff = prices[j] - prices[j-1];
                local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i][j-1] + diff);
                global[i][j] = max(local[i][j] , global[i][j-1]);
            }
        
        return global[2][len-1];
    }
};
```

#### 方法2：分治 + 贪心 （`优化空间复杂度`）

找出交易一次能获得最大利润的区间范围`[b,e]`（参考[买卖股票的最佳时机](#买卖股票的最佳时机)），设最大利润为`max_all`，再找出这个区间内交易一次亏损最多的区间`[bmid,emid]`，设最大亏损为`max_mid < 0`。同样的方法，找出左边区间`[0,b-1]`内交易一次能获得的最大利润`max_left`，对应的区间为`[left_b,left_e]`，找出右边区间`[e+1,len-1]`内交易一次能获得的的最大利润`max_right`，对应的区间为`[right_b,right_e]`。找出三者的最大值`max(max_left,max_right,-max_mid)`，那么买卖两次股票能获得最大利润有可能是以下三种情况：

  1. 如果`-max_mid`最大，说明中间亏损的金额比左边和右边区间交易一次获得的利润都大，那么就将这段最大亏损去除掉，也就是将区间`[b,e]`划分成两次交易，它们分别对应的区间为`[b,bmid]`和`[emid,e]`，这样就能得到最大利润；
  2. 如果`max_left`最大，那么左边区间的利润在弥补`[b,e]`段最大亏损的基础上还有盈余，那么就不用去除中间亏损最大的那一段，而是在`max_all`的基础上加上`max_left`，两次交易对应的区间为`[left_b,left_e]`和`[b,e]`，这样就能得到最大利润；
  3. 如果`max_right`最大，与 `情况2` 同理，两次交易对应的区间为`[b,e]`和`[right_b,right_e]`，就得到了最大利润。

因此找出三者的最大值`max(max_left,max_right,max_mid)`，那么交易两次能获得的最大利润就是 `max_all + max(max_left,max_right,max_mid)`。

* 时间复杂度O(*n*)
* 空间复杂度O(1)

```c++
class sub
{
public:
   int b;
   int e;
};

class Solution {
public:
    int max_sub(vector<int> vec,int l,int r,sub& sub)
    {
        if(l >= r) return 0;
        
        int min = l;
        int max = 0;
        for(int i=l+1;i<=r;i++)
        {
            if(vec[i] > vec[min])
            {
                int tmp = vec[i] - vec[min];
                if(tmp > max)
                {
                    max = tmp;
                    sub.b = min;
                    sub.e = i;
                }
            }
            else{
                min = i;
            }
        }
        
        return max;
    }
    
    int min_sub(vector<int> vec,int l,int r,sub& sub)
    {
        if(l >= r) return 0;
        
        int max = l;
        int min = 0;
        
        for(int i=l+1;i<=r;i++)
        {
            if(vec[i] < vec[max])
            {
                int tmp = vec[i] - vec[max];
                if(tmp < min)
                {
                    min = tmp;
                    sub.b = max;
                    sub.e = i;
                }
            }
            else{
                max = i;
            }
        }
        
        return min;
    }
    
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if(len == 0) return 0;
        
        sub sub_all,sub_mid,sub_left,sub_right;
        int max_all = max_sub(prices,0,len - 1,sub_all);
        
        int max_mid = -min_sub(prices,sub_all.b,sub_all.e,sub_mid);
        int max_left = max_sub(prices,0,sub_all.b - 1,sub_left);
        int max_right = max_sub(prices,sub_all.e + 1,len - 1,sub_right);
        
        if(max_all == 0) return 0;
        
        return max(max(max_left,max_mid),max_right) + max_all;
    }
    
};
```



## 俄罗斯套娃信封问题

[LeetCode中文](https://leetcode-cn.com/problems/russian-doll-envelopes/)

[LeetCode英文](https://leetcode.com/problems/russian-doll-envelopes/)

给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 `(w, h)` 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

**说明**:
不允许旋转信封。

**示例**:
```
输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```

### 解答
#### 方法1：动态规划

首先将`envelopes`按照信封的宽度从小到大原地排序，原问题就转化为求当前数组的最长上升子序列的长度，就是求出当前数组`envelopes`中高度组成的最长上升子序列的长度。但是要注意一个特殊情况：当宽度相等的情况下，是不符合信封套娃要求的，所以排序的时候**将宽度相等的信封按照高度从大到小排序**，可以避免错误地被算进上升子序列。上升子序列问题详见 [最大上升子序列](#最大上升子序列)。

* 时间复杂度O(*n<sup>2</sup>*)
* 空间复杂度O(*n*)

```c++
class Solution {
public:
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        if(envelopes.empty()) return 0;
        
        int len = envelopes.size();
        sort(envelopes.begin(),envelopes.end(),[](const pair<int,int>& pr1,const pair<int,int>& pr2)
             {return pr1.first < pr2.first || (pr1.first == pr2.first && pr1.second > pr2.second);});
        
        vector<int> dp(len,1);
        dp[0] = 1;
        int Max = 1;
        for(int i=1;i<len;i++)
        {
            int tmp = envelopes[i].second;
            for(int j=0;j<i;j++)
            {
                if(tmp > envelopes[j].second)
                {
                    dp[i] = max(dp[i],dp[j]+1);
                }
            }
            
            Max = max(Max,dp[i]);
        }
        
        return Max;
    }
};
```

#### 方法2：贪心

同方法1，转化成求上升子序列问题的贪心解法(`二分查找`)，详见 [最大上升子序列](#最大上升子序列)

* 时间复杂度O(*n log n*)
* 空间复杂度O(*n*)


```c++
class Solution {
public:
    int maxEnvelopes(vector<pair<int, int>>& envelopes) {
        if(envelopes.empty()) return 0;
        
        int n = envelopes.size();
        sort(envelopes.begin(),envelopes.end(),[](const pair<int,int>& pr1,const pair<int,int>& pr2)
             {return pr1.first < pr2.first || (pr1.first == pr2.first && pr1.second > pr2.second);});
        
        vector<int> vec;
        for(auto a : envelopes)
        {
            int tmp = a.second;
            auto it = lower_bound(vec.begin(),vec.end(),tmp);
            if(it == vec.end())
            {
                vec.push_back(tmp);
            }
            else{
                *it = tmp;
            }
        }
        
        return vec.size();
    }
};
```



## 递增的三元子序列

[LeetCode中文](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)

[LeetCode英文](https://leetcode.com/problems/increasing-triplet-subsequence/)

给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。

数学表达式如下:

> 如果存在这样的 *i, j, k,*  且满足 0 ≤ *i* < *j* < *k* ≤ *n*-1，
> 使得 *arr[i]* < *arr[j]* < *arr[k]* ，返回 true ; 否则返回 false 。

**说明:** 要求算法的时间复杂度为 O(*n*)，空间复杂度为 O(*1*) 。

**示例 1:**

```
输入: [1,2,3,4,5]
输出: true
```

**示例 2:**

```
输入: [5,4,3,2,1]
输出: false
```

### 解答

#### 方法1：动态规划

定义一个`dp`数组，`dp[i]`表示在`i`位置之前**小于`nums[i]`并且能组成最长上升序列的数字的个数**(包括`nums[i]`本身)，我们初始化`dp`数组都为1，然后我们开始遍历原数组，对当前数字`nums[i]`，我们遍历其之前的所有数字，如果之前某个数字`nums[j]`小于`nums[i]`，那么我们更新`dp[i] = max(dp[i], dp[j] + 1)`，如果此时`dp[i]`到3了，则返回`true`，若遍历完成，则返回`false`。

- 时间复杂度：O(*n<sup>2</sup>*)
- 空间复杂度：O(*n*)

```c++
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        if(nums.size() < 3) return false;
        vector<int> dp(nums.size(),1);
        for(int i=1;i<nums.size();i++)
        {
            for(int j=i-1;j>=0;j--)
            {
                if(nums[j] < nums[i])
                {
                    dp[i] = max(dp[j] + 1,dp[i]);
                }
                
                if(dp[i] >= 3) return true;
            }
        }
        
        return false;
    }
};
```

#### 方法2：贪心

定义两个指针`less`和`more`，初始化为整型最大值，我们遍历数组，如果`less`大于等于当前数字，则将当前数字赋给`less`；如果`less`小于当前数字且`more`大于等于当前数字，那么将当前数字赋给`more`，一旦`more`被更新了，说明前面一定会有一个数小于`more`，那么我们就成功的组成了一个长度为2的递增子序列，所以我们一旦遍历到比`more`还大的数，我们直接返回`true`。如果我们遇到比`less`小的数，仍然要更新`less`，同时有可能的话也要更新`more`为更小的值，毕竟`more`的值越小，能组成长度为3的递增序列的可能性越大。

- 时间复杂度：O(*n*)
- 空间复杂度：O(1)

```c++
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int len = nums.size();
        if(len < 3) return false;
        
        int less = INT_MAX;
        int more = INT_MAX;
        for(int i=0;i<len;i++)
        {
            if(less >= nums[i]) less = nums[i];
            else if(less < nums[i] && nums[i] <= more) more = nums[i];
            else if(more < nums[i]) return true;
        }
        
        return false;
    }
};
```



## 最长等差数列

[LeetCode中文](https://leetcode-cn.com/problems/longest-arithmetic-sequence/)

[LeetCode英文](https://leetcode.com/problems/longest-arithmetic-sequence/)

### 解答

**Python代码**

```python
from collections import defaultdict

class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        l = len(A)
        if l <= 1:
            return l
        dp = [{} for _ in range(l)]
        res = 2
        for i in range(1, l):
            for j in range(i):
                d = A[i] - A[j]
                dp[i][d] = dp[j].get(d, 1) + 1
                res = max(dp[i][d], res)
        return res
```



## 最长递增子序列的个数

[LeetCode中文](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

[LeetCode英文](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)



### 解答

**Python代码**

```python
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        dp_len, dp_num = [1] * len(nums), [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp_len[i] = max(dp_len[j] + 1, dp_len[i])
            tmp_num = 0
            for j in range(i):
                if nums[i] > nums[j] and dp_len[j] == dp_len[i] - 1:
                    tmp_num += dp_num[j]
            dp_num[i] = max(dp_num[i], tmp_num)
        max_len = max(dp_len)
        return sum(x for i, x in enumerate(dp_num) if dp_len[i] == max_len)
```


## 接雨水

[LeetCode中文](https://leetcode.cn/problems/trapping-rain-water)


### 解答

[题解](https://leetcode.cn/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/)

```c++

```

